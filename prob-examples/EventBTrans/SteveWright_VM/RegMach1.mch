MODEL RegMchR1
SETS Inst;Data;Status={LOADING,RUNNING,FAILED,HALTED}
CONSTANTS InvalidInst,ValidInst,ExecInst,StopInst,IncrInst,JumpInst,CondWriteInst,NonJumpInst,VectorWriteInst,JumpAlwaysInst,JumpCondInst,NullInst,Op1WriteInst,Op2WriteInst,ResultWriteInst,StoreWriteInst,Op1WriteImmInst,Op1WriteInstPtrInst,Op1WriteMemInst,Op2WriteImmInst,Op2WriteInstPtrInst,Op2WriteMemInst,InstArrayDom,MaxVector,CompFunc,DualOpFunc,SingleOpFunc,Data2Nat,Nat2Data,ABlankData,Inst2ImmData
PROPERTIES (ValidInst <: Inst) & (ValidInst /= {}) & (InvalidInst <: Inst) & (InvalidInst /= {}) & (Inst = (InvalidInst \/ ValidInst)) & ((InvalidInst /\ ValidInst) = {}) & (ExecInst <: ValidInst) & (ExecInst /= {}) & (StopInst <: ValidInst) & (StopInst /= {}) & (ValidInst = (StopInst \/ ExecInst)) & ((StopInst /\ ExecInst) = {}) & (IncrInst <: ExecInst) & (IncrInst /= {}) & (JumpInst <: ExecInst) & (JumpInst /= {}) & (ExecInst = (JumpInst \/ IncrInst)) & ((JumpInst /\ IncrInst) = {}) & (NonJumpInst <: IncrInst) & (VectorWriteInst <: IncrInst) & (CondWriteInst <: IncrInst) & (IncrInst = (VectorWriteInst \/ CondWriteInst \/ NonJumpInst)) & ((VectorWriteInst /\ NonJumpInst) = {}) & ((CondWriteInst /\ NonJumpInst) = {}) & ((CondWriteInst /\ VectorWriteInst) = {}) & (JumpCondInst <: JumpInst) & (JumpAlwaysInst <: JumpInst) & (JumpInst = (JumpAlwaysInst \/ JumpCondInst)) & ((JumpAlwaysInst /\ JumpCondInst) = {}) & (NullInst <: NonJumpInst) & (NullInst /= {}) & (Op1WriteInst <: NonJumpInst) & (Op1WriteInst /= {}) & (Op2WriteInst <: NonJumpInst) & (Op2WriteInst /= {}) & (StoreWriteInst <: NonJumpInst) & (StoreWriteInst /= {}) & (NonJumpInst = (Op1WriteInst \/ Op2WriteInst \/ StoreWriteInst \/ NullInst)) &
(ResultWriteInst <: VectorWriteInst) & (VectorWriteInst = ResultWriteInst) & (ResultWriteInst /= {}) & 
((Op1WriteInst /\ NullInst) = {}) & ((Op2WriteInst /\ NullInst) = {}) & ((ResultWriteInst /\ NullInst) = {}) & ((StoreWriteInst /\ NullInst) = {}) & ((ResultWriteInst /\ Op1WriteInst) = {}) & ((StoreWriteInst /\ Op1WriteInst) = {}) & ((ResultWriteInst /\ Op2WriteInst) = {}) & ((StoreWriteInst /\ Op2WriteInst) = {}) & ((StoreWriteInst /\ ResultWriteInst) = {}) & (Op1WriteImmInst <: Op1WriteInst) & (Op1WriteMemInst <: Op1WriteInst) & (Op1WriteInstPtrInst <: Op1WriteInst) & (Op1WriteInst = (Op1WriteImmInst \/ Op1WriteMemInst \/ Op1WriteInstPtrInst)) & ((Op1WriteMemInst /\ Op1WriteImmInst) = {}) & ((Op1WriteInstPtrInst /\ Op1WriteImmInst) = {}) & ((Op1WriteInstPtrInst /\ Op1WriteMemInst) = {}) &
(Op2WriteImmInst <: Op2WriteInst) & (Op2WriteMemInst <: Op2WriteInst) & (Op2WriteInstPtrInst <: Op2WriteInst) & (Op2WriteInst = (Op2WriteImmInst \/ Op2WriteMemInst \/ Op2WriteInstPtrInst)) & ((Op2WriteMemInst /\ Op2WriteImmInst) = {}) & ((Op2WriteInstPtrInst /\ Op2WriteImmInst) = {}) & ((Op2WriteInstPtrInst /\ Op2WriteMemInst) = {}) & (MaxVector : NATURAL1) & (InstArrayDom = (1 .. MaxVector)) & (SingleOpFunc : (Data --> (Data * BOOL))) & (DualOpFunc : ((Data * Data) --> (Data * BOOL))) & (CompFunc : ((Data * Data) --> BOOL)) & (Data2Nat : (Data --> NATURAL)) & (Nat2Data : (NATURAL --> Data)) & (ABlankData : Data) & (Data2Nat(ABlankData) = 0) & (Inst2ImmData : (Inst --> Data))
VARIABLES instArray,instPtr,jumpConditional,op1,op1Readable,op1Writable,op2,op2Readable,op2Writable,resReadable,resWritable,result,rwMem,status
INVARIANT (status : Status) & (instArray : (InstArrayDom --> Inst)) & (instPtr : InstArrayDom) & (jumpConditional : BOOL) & (rwMem : Data) & (op1 : Data) & (op1Writable : BOOL) & (op1Readable : BOOL) & (op2 : Data) & (op2Writable : BOOL) & (op2Readable : BOOL) & (result : Data) & (resWritable : BOOL) & (resReadable : BOOL) & instArray:POW((INTEGER * Inst)) & instPtr:INTEGER & jumpConditional:BOOL & op1:Data & op1Readable:BOOL & op1Writable:BOOL & op2:Data & op2Readable:BOOL & op2Writable:BOOL & resReadable:BOOL & resWritable:BOOL & result:Data & rwMem:Data & status:Status
ASSERTIONS (Inst /= {}) & (InvalidInst /<: ValidInst) & ((StopInst /\ ExecInst) = {}) & ((JumpInst /\ IncrInst) = {}) & ((StopInst /\ IncrInst) = {}) & ((StopInst /\ JumpInst) = {}) & (Op1WriteInst /<: ResultWriteInst) & (Op2WriteInst /<: ResultWriteInst) & (InstArrayDom /= {}) & (Data /= {})

DEFINITIONS
SET_PREF_SHOW_EVENTB_ANY_VALUES==TRUE ;
 scope_Inst == 5
INITIALISATION instArray :: (InstArrayDom --> Inst) || instPtr := 1 || status := LOADING || jumpConditional :: BOOL || rwMem :: Data || op1 :: Data || op1Writable :: BOOL || op1Readable :: BOOL || op2 :: Data || op2Writable :: BOOL || op2Readable :: BOOL || result := ABlankData || resWritable := TRUE || resReadable := FALSE
OPERATIONS
 Loading = SELECT (status = LOADING) THEN instArray :: (InstArrayDom --> Inst) || status :: {LOADING,RUNNING} END ;
 NullOk = ANY ptrInc WHERE (instArray(instPtr) : NullInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := RUNNING END ;
 Op1WriteInstPtrOk = ANY ptrInc WHERE (ptrInc : NATURAL1) & (instArray(instPtr) : Op1WriteInstPtrInst) & ((ptrInc + instPtr) : InstArrayDom) & (op1Writable = TRUE) & (status = RUNNING) THEN op1 := Nat2Data(instPtr) || op1Readable := TRUE || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op1WriteImmOk = ANY immData,ptrInc WHERE (instArray(instPtr) : Op1WriteImmInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (immData : Data) & (immData = Inst2ImmData(instArray(instPtr))) & (op1Writable = TRUE) & (status = RUNNING) THEN op1 := immData || op1Readable := TRUE || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op1WriteMemOk = ANY memAvail,memData,ptrInc WHERE (instArray(instPtr) : Op1WriteMemInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (memData : Data) & (memAvail : BOOL) & (memAvail = TRUE) & (op1Writable = TRUE) & (status = RUNNING) THEN op1 := memData || op1Readable := TRUE || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op1WriteMemNoSrc = ANY memAvail,ptrInc WHERE (instArray(instPtr) : Op1WriteMemInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (memAvail : BOOL) & (memAvail = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 Op1WriteNoDest = ANY ptrInc WHERE (instArray(instPtr) : Op1WriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (op1Writable = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 Op2WriteInstPtrOk = ANY ptrInc WHERE (ptrInc : NATURAL1) & (instArray(instPtr) : Op2WriteInstPtrInst) & ((ptrInc + instPtr) : InstArrayDom) & (op2Writable = TRUE) & (status = RUNNING) THEN op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 := Nat2Data(instPtr) || op2Readable := TRUE || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op2WriteImmOk = ANY immData,ptrInc WHERE (instArray(instPtr) : Op2WriteImmInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (immData : Data) & (immData = Inst2ImmData(instArray(instPtr))) & (op2Writable = TRUE) & (status = RUNNING) THEN op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 := immData || op2Readable := TRUE || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op2WriteMemOk = ANY memAvail,memData,ptrInc WHERE (instArray(instPtr) : Op2WriteMemInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (memData : Data) & (memAvail : BOOL) & (memAvail = TRUE) & (op2Writable = TRUE) & (status = RUNNING) THEN op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 := memData || op2Readable := TRUE || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op2WriteMemNoSrc = ANY memAvail,ptrInc WHERE (instArray(instPtr) : Op2WriteMemInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (memAvail : BOOL) & (memAvail = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 Op2WriteNoDest = ANY ptrInc WHERE (instArray(instPtr) : Op2WriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (op2Writable = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 ResWriteOk = ANY ptrInc,srcAvail,srcData WHERE (instArray(instPtr) : ResultWriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (srcData : Data) & (srcAvail : BOOL) & (srcAvail = TRUE) & (resWritable = TRUE) & (status = RUNNING) THEN op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result := srcData || resReadable := TRUE || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 ResWriteNoSrc = ANY ptrInc,srcAvail WHERE (instArray(instPtr) : ResultWriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (srcAvail : BOOL) & (srcAvail = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 ResWriteNoDest = ANY ptrInc WHERE (instArray(instPtr) : ResultWriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (resWritable = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 StoreWriteOk = ANY ptrInc,rwAvail WHERE (instArray(instPtr) : StoreWriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (resReadable = TRUE) & (rwAvail : BOOL) & (rwAvail = TRUE) & (status = RUNNING) THEN rwMem := result || instPtr := (ptrInc + instPtr) || op1Readable :: BOOL || op1Writable :: BOOL || op2Readable :: BOOL || op2Writable :: BOOL || resReadable :: BOOL || resWritable :: BOOL END ;
 StoreWriteNoSrc = ANY ptrInc WHERE (instArray(instPtr) : StoreWriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (resReadable = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 StoreWriteNoDest = ANY ptrInc,rwAvail WHERE (instArray(instPtr) : StoreWriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (rwAvail : BOOL) & (rwAvail = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 IncrInstBadPc = ANY ptrInc WHERE (instArray(instPtr) : IncrInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) /: InstArrayDom) & (status = RUNNING) THEN status := FAILED END ;
 CondWriteInst = ANY ptrInc WHERE (instArray(instPtr) : CondWriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (status = RUNNING) THEN op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || jumpConditional :: BOOL || instPtr := (ptrInc + instPtr) || status :: {RUNNING,FAILED} END ;
 JumpTrueOk = SELECT (instArray(instPtr) : JumpCondInst) & (jumpConditional = TRUE) & (resReadable = TRUE) & (Data2Nat(result) : InstArrayDom) & (status = RUNNING) THEN instPtr := Data2Nat(result) || op1Readable :: BOOL || op1Writable :: BOOL || op2Readable :: BOOL || op2Writable :: BOOL || resReadable :: BOOL || resWritable :: BOOL END ;
 JumpTrueNoVector = SELECT (instArray(instPtr) : JumpCondInst) & (jumpConditional = TRUE) & (resReadable = FALSE) & (status = RUNNING) THEN status := FAILED END ;
 JumpTrueBadPc = SELECT (instArray(instPtr) : JumpCondInst) & (jumpConditional = TRUE) & (resReadable = TRUE) & (Data2Nat(result) /: InstArrayDom) & (status = RUNNING) THEN status := FAILED END ;
 JumpFalseOk = ANY ptrInc WHERE (instArray(instPtr) : JumpCondInst) & (jumpConditional = FALSE) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) END ;
 JumpFalseBadPc = ANY ptrInc WHERE (instArray(instPtr) : JumpCondInst) & (jumpConditional = FALSE) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) /: InstArrayDom) & (status = RUNNING) THEN status := FAILED END ;
 JumpOk = SELECT (instArray(instPtr) : JumpAlwaysInst) & (resReadable = TRUE) & (Data2Nat(result) : InstArrayDom) & (status = RUNNING) THEN instPtr := Data2Nat(result) || op1Readable :: BOOL || op1Writable :: BOOL || op2Readable :: BOOL || op2Writable :: BOOL || resReadable :: BOOL || resWritable :: BOOL END ;
 JumpNoVector = SELECT (instArray(instPtr) : JumpAlwaysInst) & (resReadable = FALSE) & (status = RUNNING) THEN status := FAILED END ;
 JumpBadPc = SELECT (instArray(instPtr) : JumpAlwaysInst) & (resReadable = TRUE) & (Data2Nat(result) /: InstArrayDom) & (status = RUNNING) THEN status := FAILED END ;
 StopInstOk = SELECT (instArray(instPtr) : StopInst) & (status = RUNNING) THEN status := HALTED END ;
 BadInst = SELECT (instArray(instPtr) /: ValidInst) & (status = RUNNING) THEN status := FAILED END ;
 Halted = SELECT (status = HALTED) THEN skip END ;
 Failed = SELECT (status = FAILED) THEN skip END 
END