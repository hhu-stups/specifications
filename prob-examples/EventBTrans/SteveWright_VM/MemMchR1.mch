MODEL MemMchR1
SETS Inst;Data;Status={LOADING,RUNNING,FAILED,HALTED}
CONSTANTS InvalidInst,ValidInst,ExecInst,StopInst,IncrInst,JumpInst,CondWriteInst,NonJumpInst,VectorWriteInst,JumpAlwaysInst,JumpCondInst,NullInst,Op1WriteInst,Op2WriteInst,ResultWriteInst,StoreWriteInst,Op1WriteImmInst,Op1WriteInstPtrInst,Op1WriteMemInst,Op2WriteImmInst,Op2WriteInstPtrInst,Op2WriteMemInst,DualOpInst,SingleOpInst,Op1WriteDirInst,Op1WriteIndirInst,Op2WriteDirInst,Op2WriteIndirInst,StoreDirInst,StoreIndirInst,CompFunc,DualOpFunc,SingleOpFunc,InstArrayDom,MaxVector,MaxRoPointer,MaxRwPointer,MinRoPointer,MinRwPointer,RoDom,RwDom,Data2Nat,Nat2Data,ABlankData,Inst2ImmData
PROPERTIES (ValidInst <: Inst) & (ValidInst /= {}) & (InvalidInst <: Inst) & (InvalidInst /= {}) & (Inst = (InvalidInst \/ ValidInst)) & ((InvalidInst /\ ValidInst) = {}) & (ExecInst <: ValidInst) & (ExecInst /= {}) & (StopInst <: ValidInst) & (StopInst /= {}) & (ValidInst = (StopInst \/ ExecInst)) & ((StopInst /\ ExecInst) = {}) & (IncrInst <: ExecInst) & (IncrInst /= {}) & (JumpInst <: ExecInst) & (JumpInst /= {}) & (ExecInst = (JumpInst \/ IncrInst)) & ((JumpInst /\ IncrInst) = {}) & (NonJumpInst <: IncrInst) & (VectorWriteInst <: IncrInst) & (CondWriteInst <: IncrInst) & (IncrInst = (VectorWriteInst \/ CondWriteInst \/ NonJumpInst)) & ((VectorWriteInst /\ NonJumpInst) = {}) & ((CondWriteInst /\ NonJumpInst) = {}) & ((CondWriteInst /\ VectorWriteInst) = {}) & (JumpCondInst <: JumpInst) & (JumpAlwaysInst <: JumpInst) & (JumpInst = (JumpAlwaysInst \/ JumpCondInst)) & ((JumpAlwaysInst /\ JumpCondInst) = {}) & (NullInst <: NonJumpInst) & (NullInst /= {}) & (Op1WriteInst <: NonJumpInst) & (Op1WriteInst /= {}) & (Op2WriteInst <: NonJumpInst) & (Op2WriteInst /= {}) & (StoreWriteInst <: NonJumpInst) & (StoreWriteInst /= {}) & (NonJumpInst = (Op1WriteInst \/ Op2WriteInst \/ StoreWriteInst \/ NullInst)) & 
(ResultWriteInst <: VectorWriteInst) & (VectorWriteInst = ResultWriteInst) & (ResultWriteInst /= {}) & 
((Op1WriteInst /\ NullInst) = {}) & ((Op2WriteInst /\ NullInst) = {}) & ((ResultWriteInst /\ NullInst) = {}) & ((StoreWriteInst /\ NullInst) = {}) & 
((ResultWriteInst /\ Op1WriteInst) = {}) & ((StoreWriteInst /\ Op1WriteInst) = {}) & ((ResultWriteInst /\ Op2WriteInst) = {}) & ((StoreWriteInst /\ Op2WriteInst) = {}) & ((StoreWriteInst /\ ResultWriteInst) = {}) & (Op1WriteImmInst <: Op1WriteInst) & (Op1WriteMemInst <: Op1WriteInst) & (Op1WriteInstPtrInst <: Op1WriteInst) & (Op1WriteInst = (Op1WriteImmInst \/ Op1WriteMemInst \/ Op1WriteInstPtrInst)) & ((Op1WriteMemInst /\ Op1WriteImmInst) = {}) & ((Op1WriteInstPtrInst /\ Op1WriteImmInst) = {}) & ((Op1WriteInstPtrInst /\ Op1WriteMemInst) = {}) & 
(Op2WriteImmInst <: Op2WriteInst) & (Op2WriteMemInst <: Op2WriteInst) & (Op2WriteInstPtrInst <: Op2WriteInst) & (Op2WriteInst = (Op2WriteImmInst \/ Op2WriteMemInst \/ Op2WriteInstPtrInst)) & ((Op2WriteMemInst /\ Op2WriteImmInst) = {}) & ((Op2WriteInstPtrInst /\ Op2WriteImmInst) = {}) & ((Op2WriteInstPtrInst /\ Op2WriteMemInst) = {}) & (SingleOpInst <: ResultWriteInst) & (SingleOpInst /= {}) & (DualOpInst <: ResultWriteInst) & (DualOpInst /= {}) & (ResultWriteInst = (DualOpInst \/ SingleOpInst)) & ((DualOpInst /\ SingleOpInst) = {}) & (Op1WriteDirInst <: Op1WriteMemInst) & (Op1WriteDirInst /= {}) & (Op1WriteIndirInst <: Op1WriteMemInst) & (Op1WriteIndirInst /= {}) & (Op1WriteMemInst = (Op1WriteIndirInst \/ Op1WriteDirInst)) & ((Op1WriteIndirInst /\ Op1WriteDirInst) = {}) & 
(Op2WriteDirInst <: Op2WriteMemInst) & (Op2WriteDirInst /= {}) & (Op2WriteIndirInst <: Op2WriteMemInst) & (Op2WriteIndirInst /= {}) & (Op2WriteMemInst = (Op2WriteIndirInst \/ Op2WriteDirInst)) & ((Op2WriteIndirInst /\ Op2WriteDirInst) = {}) & 
(StoreDirInst <: StoreWriteInst) & (StoreDirInst /= {}) & (StoreIndirInst <: StoreWriteInst) & (StoreIndirInst /= {}) & (StoreWriteInst = (StoreIndirInst \/ StoreDirInst)) & ((StoreIndirInst /\ StoreDirInst) = {}) & (SingleOpFunc : (Data --> (Data * BOOL))) & (DualOpFunc : ((Data * Data) --> (Data * BOOL))) & (CompFunc : ((Data * Data) --> BOOL)) & (MaxVector : NATURAL1) & (InstArrayDom = (1 .. MaxVector)) & (MinRwPointer : NATURAL1) & (MaxRwPointer : NATURAL1) & (MinRwPointer <= MaxRwPointer) & (RwDom = (MinRwPointer .. MaxRwPointer)) & ! (d,x,A).((d : Data & x : INTEGER & A : POW(INTEGER * Data)) => (((x : RwDom) & (A : (RwDom --> Data)) & (d : Data)) => (d = A(x)))) & 
(MinRoPointer : NATURAL1) & (MaxRoPointer : NATURAL1) & (MinRoPointer <= MaxRoPointer) & (RoDom = (MinRoPointer .. MaxRoPointer)) & ! (d,x,A).((d : Data & x : INTEGER & A : POW(INTEGER * Data)) => (((x : RoDom) & (A : (RoDom --> Data)) & (d : Data)) => (d = A(x)))) & (MinRwPointer > MaxRoPointer) & (Data2Nat : (Data --> NATURAL)) & (Nat2Data : (NATURAL --> Data)) & (ABlankData : Data) & (Data2Nat(ABlankData) = 0) & (Inst2ImmData : (Inst --> Data))
VARIABLES instArray,instPtr,jumpConditional,op1,op1Readable,op1Writable,op2,op2Readable,op2Writable,resReadable,resWritable,result,roArray,rwArray,status
INVARIANT (status : Status) & (instArray : (InstArrayDom --> Inst)) & (instPtr : InstArrayDom) & (jumpConditional : BOOL) & (op1 : Data) & (op1Writable : BOOL) & (op1Readable : BOOL) & (op2 : Data) & (op2Writable : BOOL) & (op2Readable : BOOL) & (result : Data) & (resWritable : BOOL) & (resReadable : BOOL) & (rwArray : (RwDom --> Data)) & (roArray : (RoDom --> Data)) & instArray:POW((INTEGER * Inst)) & instPtr:INTEGER & jumpConditional:BOOL & op1:Data & op1Readable:BOOL & op1Writable:BOOL & op2:Data & op2Readable:BOOL & op2Writable:BOOL & resReadable:BOOL & resWritable:BOOL & result:Data & roArray:POW((INTEGER * Data)) & rwArray:POW((INTEGER * Data)) & status:Status
ASSERTIONS (Inst /= {}) & (InvalidInst /<: ValidInst) & ((StopInst /\ ExecInst) = {}) & ((JumpInst /\ IncrInst) = {}) & ((StopInst /\ IncrInst) = {}) & ((StopInst /\ JumpInst) = {}) & (Op1WriteInst /<: ResultWriteInst) & (Op2WriteInst /<: ResultWriteInst) & (SingleOpInst /<: DualOpInst) & (Op1WriteInst = (Op1WriteImmInst \/ Op1WriteDirInst \/ Op1WriteIndirInst \/ Op1WriteInstPtrInst)) & (Op2WriteInst = (Op2WriteImmInst \/ Op2WriteDirInst \/ Op2WriteIndirInst \/ Op2WriteInstPtrInst)) & (Data /= {}) & (InstArrayDom /= {}) & (0 /: RwDom) & (RwDom /= {}) & (0 /: RoDom) & (RoDom /= {}) & ((RoDom /\ RwDom) = {})

DEFINITIONS
SET_PREF_SHOW_EVENTB_ANY_VALUES==TRUE 
INITIALISATION instArray :: (InstArrayDom --> Inst) || instPtr := 1 || status := LOADING || jumpConditional :: BOOL || op1 :: Data || op1Writable :: BOOL || op1Readable :: BOOL || op2 :: Data || op2Writable :: BOOL || op2Readable :: BOOL || result := ABlankData || resWritable := TRUE || resReadable := FALSE || rwArray :: (RwDom --> Data) || roArray :: (RoDom --> Data)
OPERATIONS
 Loading = SELECT (status = LOADING) THEN instArray :: (InstArrayDom --> Inst) || roArray :: (RoDom --> Data) || status :: {LOADING,RUNNING} END ;
 NullOk = ANY ptrInc WHERE (instArray(instPtr) : NullInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := RUNNING END ;
 Op1WriteInstPtrOk = ANY ptrInc WHERE (ptrInc : NATURAL1) & (instArray(instPtr) : Op1WriteInstPtrInst) & ((ptrInc + instPtr) : InstArrayDom) & (op1Writable = TRUE) & (status = RUNNING) THEN op1 := Nat2Data(instPtr) || op1Readable := TRUE || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op1WriteImmOk = ANY immData,ptrInc WHERE (instArray(instPtr) : Op1WriteImmInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (immData : Data) & (immData = Inst2ImmData(instArray(instPtr))) & (op1Writable = TRUE) & (status = RUNNING) THEN op1 := immData || op1Readable := TRUE || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op1WriteRwOk = ANY ptr,ptrInc WHERE (instArray(instPtr) : Op1WriteMemInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (ptr : NATURAL) & (ptr : RwDom) & (op1Writable = TRUE) & (status = RUNNING) THEN op1 := rwArray(ptr) || op1Readable := TRUE || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op1WriteRoOk = ANY ptr,ptrInc WHERE (instArray(instPtr) : Op1WriteMemInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (ptr : NATURAL) & (ptr : RoDom) & (op1Writable = TRUE) & (status = RUNNING) THEN op1 := roArray(ptr) || op1Readable := TRUE || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op1WriteMemBadPtr = ANY ptr,ptrInc WHERE (instArray(instPtr) : Op1WriteMemInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (ptr : NATURAL) & (ptr /: RwDom) & (ptr /: RoDom) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 Op1WriteNoDest = ANY ptrInc WHERE (instArray(instPtr) : Op1WriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (op1Writable = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 Op2WriteInstPtrOk = ANY ptrInc WHERE (ptrInc : NATURAL1) & (instArray(instPtr) : Op2WriteInstPtrInst) & ((ptrInc + instPtr) : InstArrayDom) & (op2Writable = TRUE) & (status = RUNNING) THEN op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 := Nat2Data(instPtr) || op2Readable := TRUE || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op2WriteImmOk = ANY immData,ptrInc WHERE (instArray(instPtr) : Op2WriteImmInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (immData : Data) & (immData = Inst2ImmData(instArray(instPtr))) & (op2Writable = TRUE) & (status = RUNNING) THEN op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 := immData || op2Readable := TRUE || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op2WriteRwOk = ANY ptr,ptrInc WHERE (instArray(instPtr) : Op2WriteMemInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (ptr : NATURAL) & (ptr : RwDom) & (op2Writable = TRUE) & (status = RUNNING) THEN op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 := rwArray(ptr) || op2Readable := TRUE || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op2WriteRoOk = ANY ptr,ptrInc WHERE (instArray(instPtr) : Op2WriteMemInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (ptr : NATURAL) & (ptr : RoDom) & (op2Writable = TRUE) & (status = RUNNING) THEN op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 := roArray(ptr) || op2Readable := TRUE || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op2WriteMemBadPtr = ANY ptr,ptrInc WHERE (instArray(instPtr) : Op2WriteMemInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (ptr : NATURAL) & (ptr /: RwDom) & (ptr /: RoDom) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 Op2WriteNoDest = ANY ptrInc WHERE (instArray(instPtr) : Op2WriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (op2Writable = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 SingleOpOk = ANY funcOk,funcRes,ptrInc WHERE (ptrInc : NATURAL1) & (funcRes : Data) & (funcOk : BOOL) & ((funcRes |-> funcOk) = SingleOpFunc(op1)) & (instArray(instPtr) : SingleOpInst) & ((ptrInc + instPtr) : InstArrayDom) & (op1Readable = TRUE) & (resWritable = TRUE) & (funcOk = TRUE) & (status = RUNNING) THEN op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result := funcRes || resReadable := TRUE || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 SingleOpNoOp = ANY ptrInc WHERE (ptrInc : NATURAL1) & (instArray(instPtr) : SingleOpInst) & ((ptrInc + instPtr) : InstArrayDom) & (op1Readable = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 SingleOpFail = ANY funcOk,funcRes,ptrInc WHERE (ptrInc : NATURAL1) & (funcRes : Data) & (funcOk : BOOL) & ((funcRes |-> funcOk) = SingleOpFunc(op1)) & (instArray(instPtr) : SingleOpInst) & ((ptrInc + instPtr) : InstArrayDom) & (op1Readable = TRUE) & (resWritable = TRUE) & (funcOk = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 DualOpOk = ANY funcOk,funcRes,ptrInc WHERE (ptrInc : NATURAL1) & (funcRes : Data) & (funcOk : BOOL) & ((funcRes |-> funcOk) = DualOpFunc((op1 |-> op2))) & (instArray(instPtr) : DualOpInst) & ((ptrInc + instPtr) : InstArrayDom) & (op1Readable = TRUE) & (op2Readable = TRUE) & (resWritable = TRUE) & (funcOk = TRUE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result := funcRes || resReadable := TRUE || resWritable :: BOOL END ;
 DualOpNoOp = ANY opsAvail,ptrInc WHERE (ptrInc : NATURAL1) & (instArray(instPtr) : DualOpInst) & ((ptrInc + instPtr) : InstArrayDom) & (opsAvail : BOOL) & (opsAvail = bool(((op2Readable = TRUE) & (op1Readable = TRUE)))) & (opsAvail = FALSE) & (resWritable = TRUE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 DualOpFail = ANY funcOk,funcRes,ptrInc WHERE (ptrInc : NATURAL1) & (funcRes : Data) & (funcOk : BOOL) & ((funcRes |-> funcOk) = DualOpFunc((op1 |-> op2))) & (instArray(instPtr) : DualOpInst) & ((ptrInc + instPtr) : InstArrayDom) & (op1Readable = TRUE) & (op2Readable = TRUE) & (resWritable = TRUE) & (funcOk = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 ResWriteNoDest = ANY ptrInc WHERE (instArray(instPtr) : ResultWriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (resWritable = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 StoreWriteOk = ANY ptr,ptrInc WHERE (instArray(instPtr) : StoreWriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (resReadable = TRUE) & (ptr : NATURAL) & (ptr : RwDom) & (status = RUNNING) THEN rwArray := ({(ptr |-> result)} <+ rwArray) || op1Readable :: BOOL || op1Writable :: BOOL || op2Readable :: BOOL || op2Writable :: BOOL || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 StoreWriteNoSrc = ANY ptrInc WHERE (instArray(instPtr) : StoreWriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (resReadable = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 StoreWriteBadPtr = ANY ptr,ptrInc WHERE (instArray(instPtr) : StoreWriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (ptr : NATURAL) & (ptr /: RwDom) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 IncrInstBadPc = ANY ptrInc WHERE (instArray(instPtr) : IncrInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) /: InstArrayDom) & (status = RUNNING) THEN status := FAILED END ;
 CondWriteOk = ANY compRes,ptrInc WHERE (ptrInc : NATURAL1) & (compRes : BOOL) & (compRes = CompFunc((op1 |-> op2))) & (instArray(instPtr) : CondWriteInst) & ((ptrInc + instPtr) : InstArrayDom) & (op1Readable = TRUE) & (op2Readable = TRUE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || jumpConditional := compRes END ;
 CondWriteNoOp = ANY opsAvail,ptrInc WHERE (ptrInc : NATURAL1) & (instArray(instPtr) : CondWriteInst) & ((ptrInc + instPtr) : InstArrayDom) & (opsAvail : BOOL) & (opsAvail = bool(((op2Readable = TRUE) & (op1Readable = TRUE)))) & (opsAvail = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 JumpTrueOk = SELECT (instArray(instPtr) : JumpCondInst) & (jumpConditional = TRUE) & (resReadable = TRUE) & (Data2Nat(result) : InstArrayDom) & (status = RUNNING) THEN instPtr := Data2Nat(result) || op1Readable :: BOOL || op1Writable :: BOOL || op2Readable :: BOOL || op2Writable :: BOOL || resReadable :: BOOL || resWritable :: BOOL END ;
 JumpTrueNoVector = SELECT (instArray(instPtr) : JumpCondInst) & (jumpConditional = TRUE) & (resReadable = FALSE) & (status = RUNNING) THEN status := FAILED END ;
 JumpTrueBadPc = SELECT (instArray(instPtr) : JumpCondInst) & (jumpConditional = TRUE) & (resReadable = TRUE) & (Data2Nat(result) /: InstArrayDom) & (status = RUNNING) THEN status := FAILED END ;
 JumpFalseOk = ANY ptrInc WHERE (instArray(instPtr) : JumpCondInst) & (jumpConditional = FALSE) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) END ;
 JumpFalseBadPc = ANY ptrInc WHERE (instArray(instPtr) : JumpCondInst) & (jumpConditional = FALSE) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) /: InstArrayDom) & (status = RUNNING) THEN status := FAILED END ;
 JumpOk = SELECT (instArray(instPtr) : JumpAlwaysInst) & (resReadable = TRUE) & (Data2Nat(result) : InstArrayDom) & (status = RUNNING) THEN instPtr := Data2Nat(result) || op1Readable :: BOOL || op1Writable :: BOOL || op2Readable :: BOOL || op2Writable :: BOOL || resReadable :: BOOL || resWritable :: BOOL END ;
 JumpNoVector = SELECT (instArray(instPtr) : JumpAlwaysInst) & (resReadable = FALSE) & (status = RUNNING) THEN status := FAILED END ;
 JumpBadPc = SELECT (instArray(instPtr) : JumpAlwaysInst) & (resReadable = TRUE) & (Data2Nat(result) /: InstArrayDom) & (status = RUNNING) THEN status := FAILED END ;
 StopInstOk = SELECT (instArray(instPtr) : StopInst) & (status = RUNNING) THEN status := HALTED END ;
 BadInst = SELECT (instArray(instPtr) /: ValidInst) & (status = RUNNING) THEN status := FAILED END ;
 Halted = SELECT (status = HALTED) THEN skip END ;
 Failed = SELECT (status = FAILED) THEN skip END 
END