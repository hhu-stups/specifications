MODEL RegMchR4
SETS Inst;Data;Status={LOADING,RUNNING,FAILED,HALTED}

DEFINITIONS
  SET_PREF_SHOW_EVENTB_ANY_VALUES==TRUE ;
  scope_Inst == 10;
  SET_PREF_MAXINT == 10
CONSTANTS
InvalidInst,ValidInst,ExecInst,StopInst,IncrInst,JumpInst,CondWriteInst,NonJumpInst,VectorWriteInst,JumpAlwaysInst,JumpCondInst,NullInst,Op1WriteInst,Op2WriteInst,ResultWriteInst,StoreWriteInst,Op1WriteImmInst,Op1WriteInstPtrInst,Op1WriteMemInst,Op2WriteImmInst,Op2WriteInstPtrInst,Op2WriteMemInst,DualOpInst,SingleOpInst,InstArrayDom,MaxVector,CompFunc,DualOpFunc,SingleOpFunc,Data2Nat,Nat2Data,ABlankData,Inst2ImmData
PROPERTIES (ValidInst <: Inst) & (ValidInst /= {}) &
 (InvalidInst <: Inst) & (InvalidInst /= {}) & 
 (Inst = (InvalidInst \/ ValidInst)) & 
 ((InvalidInst /\ ValidInst) = {}) &
 (ExecInst <: ValidInst) & (ExecInst /= {}) & (StopInst <: ValidInst) &
 (StopInst /= {}) & (ValidInst = (StopInst \/ ExecInst)) &
 ((StopInst /\ ExecInst) = {}) & (IncrInst <: ExecInst) &
 (IncrInst /= {}) & (JumpInst <: ExecInst) & (JumpInst /= {}) &
 (ExecInst = (JumpInst \/ IncrInst)) & ((JumpInst /\ IncrInst) = {}) &
 (NonJumpInst <: IncrInst) & (VectorWriteInst <: IncrInst) & (CondWriteInst <: IncrInst) &
 (IncrInst = (VectorWriteInst \/ CondWriteInst \/ NonJumpInst)) & ((VectorWriteInst /\ NonJumpInst) = {}) &
 ((CondWriteInst /\ NonJumpInst) = {}) & ((CondWriteInst /\ VectorWriteInst) = {}) & (JumpCondInst <: JumpInst) & (JumpAlwaysInst <: JumpInst) & (JumpInst = (JumpAlwaysInst \/ JumpCondInst)) & ((JumpAlwaysInst /\ JumpCondInst) = {}) & (NullInst <: NonJumpInst) & (NullInst /= {}) & (Op1WriteInst <: NonJumpInst) & (Op1WriteInst /= {}) & (Op2WriteInst <: NonJumpInst) & (Op2WriteInst /= {}) & (StoreWriteInst <: NonJumpInst) & (StoreWriteInst /= {}) & (NonJumpInst = (Op1WriteInst \/ Op2WriteInst \/ StoreWriteInst \/ NullInst)) &
(ResultWriteInst <: VectorWriteInst) & (VectorWriteInst = ResultWriteInst) & (ResultWriteInst /= {}) & ((Op1WriteInst /\ NullInst) = {}) & ((Op2WriteInst /\ NullInst) = {}) & ((ResultWriteInst /\ NullInst) = {}) & ((StoreWriteInst /\ NullInst) = {}) & 
((ResultWriteInst /\ Op1WriteInst) = {}) & ((StoreWriteInst /\ Op1WriteInst) = {}) &
 ((ResultWriteInst /\ Op2WriteInst) = {}) & ((StoreWriteInst /\ Op2WriteInst) = {}) & ((StoreWriteInst /\ ResultWriteInst) = {}) & (Op1WriteImmInst <: Op1WriteInst) & (Op1WriteMemInst <: Op1WriteInst) &
 (Op1WriteInstPtrInst <: Op1WriteInst) & (Op1WriteInst = (Op1WriteImmInst \/ Op1WriteMemInst \/ Op1WriteInstPtrInst)) & ((Op1WriteMemInst /\ Op1WriteImmInst) = {}) & ((Op1WriteInstPtrInst /\ Op1WriteImmInst) = {}) & ((Op1WriteInstPtrInst /\ Op1WriteMemInst) = {}) & 
 (Op2WriteImmInst <: Op2WriteInst) & (Op2WriteMemInst <: Op2WriteInst) & (Op2WriteInstPtrInst <: Op2WriteInst) & (Op2WriteInst = (Op2WriteImmInst \/ Op2WriteMemInst \/ Op2WriteInstPtrInst)) & ((Op2WriteMemInst /\ Op2WriteImmInst) = {}) &
 ((Op2WriteInstPtrInst /\ Op2WriteImmInst) = {}) & ((Op2WriteInstPtrInst /\ Op2WriteMemInst) = {}) & (SingleOpInst <: ResultWriteInst) & (SingleOpInst /= {}) & (DualOpInst <: ResultWriteInst) & (DualOpInst /= {}) & (ResultWriteInst = (DualOpInst \/ SingleOpInst)) & ((DualOpInst /\ SingleOpInst) = {}) & (MaxVector : NATURAL1) & (InstArrayDom = (1 .. MaxVector)) &
 (SingleOpFunc : (Data --> (Data * BOOL))) &
 (DualOpFunc : ((Data * Data) --> (Data * BOOL))) & (CompFunc : ((Data * Data) --> BOOL)) & (Data2Nat : (Data --> NATURAL)) & (Nat2Data : (NATURAL --> Data)) & (ABlankData : Data) & (Data2Nat(ABlankData) = 0) & (Inst2ImmData : (Inst --> Data))
VARIABLES instArray,instPtr,jumpConditional,op1,op1Readable,op1Writable,op2,op2Readable,op2Writable,resReadable,resWritable,result,roMem,rwMem,status
INVARIANT (status : Status) & (instArray : (InstArrayDom --> Inst)) & (instPtr : InstArrayDom) & (jumpConditional : BOOL) & (rwMem : Data) & (op1 : Data) & (op1Writable : BOOL) & (op1Readable : BOOL) & (op2 : Data) & (op2Writable : BOOL) & (op2Readable : BOOL) & (result : Data) & (resWritable : BOOL) & (resReadable : BOOL) & (roMem : Data) & instArray:POW((INTEGER * Inst)) & instPtr:INTEGER & jumpConditional:BOOL & op1:Data & op1Readable:BOOL & op1Writable:BOOL & op2:Data & op2Readable:BOOL & op2Writable:BOOL & resReadable:BOOL & resWritable:BOOL & result:Data & roMem:Data & rwMem:Data & status:Status
ASSERTIONS (Inst /= {}) & (InvalidInst /<: ValidInst) & ((StopInst /\ ExecInst) = {}) & ((JumpInst /\ IncrInst) = {}) & ((StopInst /\ IncrInst) = {}) & ((StopInst /\ JumpInst) = {}) & (Op1WriteInst /<: ResultWriteInst) & (Op2WriteInst /<: ResultWriteInst) & (SingleOpInst /<: DualOpInst) & (InstArrayDom /= {}) & (Data /= {})

INITIALISATION instArray :: (InstArrayDom --> Inst) || instPtr := 1 || status := LOADING || jumpConditional :: BOOL || rwMem :: Data || roMem :: Data || op1 :: Data || op1Writable :: BOOL || op1Readable :: BOOL || op2 :: Data || op2Writable :: BOOL || op2Readable :: BOOL || result := ABlankData || resWritable := TRUE || resReadable := FALSE
OPERATIONS
 Loading = SELECT (status = LOADING) THEN status :: {RUNNING,LOADING} || instArray :: (InstArrayDom --> Inst) || roMem :: Data END ;
 NullOk = ANY ptrInc WHERE (instArray(instPtr) : NullInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := RUNNING END ;
 Op1WriteInstPtrOk = ANY ptrInc WHERE (ptrInc : NATURAL1) & (instArray(instPtr) : Op1WriteInstPtrInst) & ((ptrInc + instPtr) : InstArrayDom) & (op1Writable = TRUE) & (status = RUNNING) THEN op1 := Nat2Data(instPtr) || op1Readable := TRUE || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op1WriteImmOk = ANY immData,ptrInc WHERE (instArray(instPtr) : Op1WriteImmInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (immData : Data) & (immData = Inst2ImmData(instArray(instPtr))) & (op1Writable = TRUE) & (status = RUNNING) THEN op1 := immData || op1Readable := TRUE || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op1WriteRwOk = ANY ptrInc,roAvail,rwAvail WHERE (instArray(instPtr) : Op1WriteMemInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (rwAvail : BOOL) & (roAvail : BOOL) & (rwAvail = TRUE) & (roAvail = FALSE) & (op1Writable = TRUE) & (status = RUNNING) THEN op1 := rwMem || op1Readable := TRUE || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op1WriteRoOk = ANY ptrInc,roAvail,rwAvail WHERE (instArray(instPtr) : Op1WriteMemInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (rwAvail : BOOL) & (roAvail : BOOL) & (rwAvail = FALSE) & (roAvail = TRUE) & (op1Writable = TRUE) & (status = RUNNING) THEN op1 := roMem || op1Readable := TRUE || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op1WriteMemNoSrc = ANY ptrInc,roAvail,rwAvail WHERE (instArray(instPtr) : Op1WriteMemInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (rwAvail : BOOL) & (rwAvail = FALSE) & (roAvail : BOOL) & (roAvail = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 Op1WriteNoDest = ANY ptrInc WHERE (instArray(instPtr) : Op1WriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (op1Writable = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 Op2WriteInstPtrOk = ANY ptrInc WHERE (ptrInc : NATURAL1) & (instArray(instPtr) : Op2WriteInstPtrInst) & ((ptrInc + instPtr) : InstArrayDom) & (op2Writable = TRUE) & (status = RUNNING) THEN op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 := Nat2Data(instPtr) || op2Readable := TRUE || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op2WriteImmOk = ANY immData,ptrInc WHERE (instArray(instPtr) : Op2WriteImmInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (immData : Data) & (immData = Inst2ImmData(instArray(instPtr))) & (op2Writable = TRUE) & (status = RUNNING) THEN op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 := immData || op2Readable := TRUE || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op2WriteRwOk = ANY ptrInc,roAvail,rwAvail WHERE (instArray(instPtr) : Op2WriteMemInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (rwAvail : BOOL) & (roAvail : BOOL) & (rwAvail = TRUE) & (roAvail = FALSE) & (op2Writable = TRUE) & (status = RUNNING) THEN op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 := rwMem || op2Readable := TRUE || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op2WriteRoOk = ANY ptrInc,roAvail,rwAvail WHERE (instArray(instPtr) : Op2WriteMemInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (rwAvail : BOOL) & (roAvail : BOOL) & (rwAvail = FALSE) & (roAvail = TRUE) & (op2Writable = TRUE) & (status = RUNNING) THEN op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 := roMem || op2Readable := TRUE || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 Op2WriteMemNoSrc = ANY ptrInc,roAvail,rwAvail WHERE (instArray(instPtr) : Op2WriteMemInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (rwAvail : BOOL) & (rwAvail = FALSE) & (roAvail : BOOL) & (roAvail = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 Op2WriteNoDest = ANY ptrInc WHERE (instArray(instPtr) : Op2WriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (op2Writable = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 SingleOpOk = ANY funcOk,funcRes,ptrInc WHERE (ptrInc : NATURAL1) & (funcRes : Data) & (funcOk : BOOL) & ((funcRes |-> funcOk) = SingleOpFunc(op1)) & (instArray(instPtr) : SingleOpInst) & ((ptrInc + instPtr) : InstArrayDom) & (op1Readable = TRUE) & (resWritable = TRUE) & (funcOk = TRUE) & (status = RUNNING) THEN op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result := funcRes || resReadable := TRUE || resWritable :: BOOL || instPtr := (ptrInc + instPtr) END ;
 SingleOpNoOp = ANY ptrInc WHERE (ptrInc : NATURAL1) & (instArray(instPtr) : SingleOpInst) & ((ptrInc + instPtr) : InstArrayDom) & (op1Readable = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 SingleOpFail = ANY funcOk,funcRes,ptrInc WHERE (ptrInc : NATURAL1) & (funcRes : Data) & (funcOk : BOOL) & ((funcRes |-> funcOk) = SingleOpFunc(op1)) & (instArray(instPtr) : SingleOpInst) & ((ptrInc + instPtr) : InstArrayDom) & (op1Readable = TRUE) & (resWritable = TRUE) & (funcOk = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 DualOpOk = ANY funcOk,funcRes,ptrInc WHERE (ptrInc : NATURAL1) & (funcRes : Data) & (funcOk : BOOL) & ((funcRes |-> funcOk) = DualOpFunc((op1 |-> op2))) & (instArray(instPtr) : DualOpInst) & ((ptrInc + instPtr) : InstArrayDom) & (op1Readable = TRUE) & (op2Readable = TRUE) & (resWritable = TRUE) & (funcOk = TRUE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result := funcRes || resReadable := TRUE || resWritable :: BOOL END ;
 DualOpNoOp = ANY opsAvail,ptrInc WHERE (ptrInc : NATURAL1) & (instArray(instPtr) : DualOpInst) & ((ptrInc + instPtr) : InstArrayDom) & (opsAvail : BOOL) & (opsAvail = bool(((op2Readable = TRUE) & (op1Readable = TRUE)))) & (opsAvail = FALSE) & (resWritable = TRUE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 DualOpFail = ANY funcOk,funcRes,ptrInc WHERE (ptrInc : NATURAL1) & (funcRes : Data) & (funcOk : BOOL) & ((funcRes |-> funcOk) = DualOpFunc((op1 |-> op2))) & (instArray(instPtr) : DualOpInst) & ((ptrInc + instPtr) : InstArrayDom) & (op1Readable = TRUE) & (op2Readable = TRUE) & (resWritable = TRUE) & (funcOk = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 CondWriteOk = ANY compRes,ptrInc WHERE (ptrInc : NATURAL1) & (compRes : BOOL) & (compRes = CompFunc((op1 |-> op2))) & (instArray(instPtr) : CondWriteInst) & ((ptrInc + instPtr) : InstArrayDom) & (op1Readable = TRUE) & (op2Readable = TRUE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || op1 :: Data || op1Readable :: BOOL || op1Writable :: BOOL || op2 :: Data || op2Readable :: BOOL || op2Writable :: BOOL || result :: Data || resReadable :: BOOL || resWritable :: BOOL || jumpConditional := compRes END ;
 CondWriteNoOp = ANY opsAvail,ptrInc WHERE (ptrInc : NATURAL1) & (instArray(instPtr) : CondWriteInst) & ((ptrInc + instPtr) : InstArrayDom) & (opsAvail : BOOL) & (opsAvail = bool(((op2Readable = TRUE) & (op1Readable = TRUE)))) & (opsAvail = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 ResWriteNoDest = ANY ptrInc WHERE (instArray(instPtr) : ResultWriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (resWritable = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 StoreWriteOk = ANY ptrInc,rwAvail WHERE (instArray(instPtr) : StoreWriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (resReadable = TRUE) & (rwAvail : BOOL) & (rwAvail = TRUE) & (status = RUNNING) THEN rwMem := result || instPtr := (ptrInc + instPtr) || op1Readable :: BOOL || op1Writable :: BOOL || op2Readable :: BOOL || op2Writable :: BOOL || resReadable :: BOOL || resWritable :: BOOL END ;
 StoreWriteNoSrc = ANY ptrInc WHERE (instArray(instPtr) : StoreWriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (resReadable = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 StoreWriteNoDest = ANY ptrInc,rwAvail WHERE (instArray(instPtr) : StoreWriteInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (rwAvail : BOOL) & (rwAvail = FALSE) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) || status := FAILED END ;
 IncrInstBadPc = ANY ptrInc WHERE (instArray(instPtr) : IncrInst) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) /: InstArrayDom) & (status = RUNNING) THEN status := FAILED END ;
 JumpTrueOk = SELECT (instArray(instPtr) : JumpCondInst) & (jumpConditional = TRUE) & (resReadable = TRUE) & (Data2Nat(result) : InstArrayDom) & (status = RUNNING) THEN instPtr := Data2Nat(result) || op1Readable :: BOOL || op1Writable :: BOOL || op2Readable :: BOOL || op2Writable :: BOOL || resReadable :: BOOL || resWritable :: BOOL END ;
 JumpTrueNoVector = SELECT (instArray(instPtr) : JumpCondInst) & (jumpConditional = TRUE) & (resReadable = FALSE) & (status = RUNNING) THEN status := FAILED END ;
 JumpTrueBadPc = SELECT (instArray(instPtr) : JumpCondInst) & (jumpConditional = TRUE) & (resReadable = TRUE) & (Data2Nat(result) /: InstArrayDom) & (status = RUNNING) THEN status := FAILED END ;
 JumpFalseOk = ANY ptrInc WHERE (instArray(instPtr) : JumpCondInst) & (jumpConditional = FALSE) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) : InstArrayDom) & (status = RUNNING) THEN instPtr := (ptrInc + instPtr) END ;
 JumpFalseBadPc = ANY ptrInc WHERE (instArray(instPtr) : JumpCondInst) & (jumpConditional = FALSE) & (ptrInc : NATURAL1) & ((ptrInc + instPtr) /: InstArrayDom) & (status = RUNNING) THEN status := FAILED END ;
 JumpOk = SELECT (instArray(instPtr) : JumpAlwaysInst) & (resReadable = TRUE) & (Data2Nat(result) : InstArrayDom) & (status = RUNNING) THEN instPtr := Data2Nat(result) || op1Readable :: BOOL || op1Writable :: BOOL || op2Readable :: BOOL || op2Writable :: BOOL || resReadable :: BOOL || resWritable :: BOOL END ;
 JumpNoVector = SELECT (instArray(instPtr) : JumpAlwaysInst) & (resReadable = FALSE) & (status = RUNNING) THEN status := FAILED END ;
 JumpBadPc = SELECT (instArray(instPtr) : JumpAlwaysInst) & (resReadable = TRUE) & (Data2Nat(result) /: InstArrayDom) & (status = RUNNING) THEN status := FAILED END ;
 StopInstOk = SELECT (instArray(instPtr) : StopInst) & (status = RUNNING) THEN status := HALTED END ;
 BadInst = SELECT (instArray(instPtr) /: ValidInst) & (status = RUNNING) THEN status := FAILED END ;
 Halted = SELECT (status = HALTED) THEN skip END ;
 Failed = SELECT (status = FAILED) THEN skip END 
END