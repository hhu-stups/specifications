IMPLEMENTATION

/*"
The implementation is built on the machines generated by BASE
generator; Person2Base.bse provides the specifications Person2Base and
Person2BaseCtx (a `context' machine) together with their implementations.
"*/

  Person2I

REFINES

  Person2

SEES

/*"
We must ensure that the context machine provided by the BASE generator
is in scope.
"*/

  String_TYPE, Bool_TYPE, Scalar_TYPE, Person2BaseCtx

IMPORTS

/*"
We import the generated machine.
"*/

  Person2Base(max_person,SEX)

PROPERTIES

/*"
We set our abstract object set equal to that provided in
{\em Person2BaseCtx\/}.
"*/

  PERSON = personbase_ABSOBJ

INVARIANT

/*"
Each of the abstract variables is equated to those provided in
{\em Person2Base\/}.
"*/

  person = personbase &
  person_name = name &
  person_age = age &
  person_sex = sex


OPERATIONS

/*"
{\bf Add\_person}\\
The operation provided for creating a new person, {\em make\_personbase\/},
takes a person's age and sex as input and returns a boolean value
indicating the success or otherwise of the operation (insufficient
memory may not have been allocated causing it to fail) together with a
token (which, if the operation is successful, points to the
newly-created person). Note that the name is not taken as a parameter:
mandatory strings, sequences and sets of a base are initialised to
empty when a new base record is created, and therefore if the create
operation is successful, we call the operation {\em mod\_name\/} with
the new token and the person's name as parameters; this operation may
also fail for the same reason as that given above, and in this case we
must be sure to kill the newly-created person.
"*/

  rep <-- Add_person(name_inp,age_inp,sex_inp) =
    VAR rep_0,new_person_0 IN
      rep_0,new_person_0<--make_personbase(age_inp,sex_inp);
      IF (rep_0=TRUE) THEN
        rep_0<--mod_name(new_person_0,name_inp);
        IF (rep_0=FALSE) THEN
          kill_personbase(new_person_0)
        END
      END;
      rep:=rep_0
    END;

/*"
{\bf Get\_person\_details}\\
The operation provided for a key search on a person's name,
{\em key\_search\_name\/} takes the name as parameter, and, if it is
stored, returns the token for the record, together with a report
indicating its success. We may then use the value operations provided
for age and sex, {\em val\_age\/} and {\em val\_sex\/}, both of which
take the token as input. If the key search operation was unsuccessful,
we return $0$ and {\em male\/} (the report indicating that the
operation failed).
"*/

  rep,age_out,sex_out <-- Get_person_details(name_inp) =
    VAR bb,person_tok IN
      bb,person_tok<--key_search_name(name_inp);
      rep:=bb;
      IF bb=TRUE THEN
        age_out<--val_age(person_tok);
        sex_out<--val_sex(person_tok)
      ELSE
        age_out:=0; sex_out:=male
      END
    END;        

/*"
{\bf Remove\_person}\\
This is similar to the above operation; if the key search is
successful we call the operation to remove a record,
{\em kill\_personbase\/}.
"*/

  rep <-- Remove_person(name_inp) =
    VAR bb,person_tok IN
      bb,person_tok<--key_search_name(name_inp);
      IF bb=TRUE THEN
         kill_personbase(person_tok)
      END;
      rep:=bb 
    END;      

/*"
{\bf Save\_Person}\\
We use the {\em save\_Person2Base\/} operation provided to write the
entire database to file.
"*/

  Save_Person = VAR rep IN rep <-- save_Person2Base END ;

/*"
{\bf  Restore\_Person}\\
We use the {\em restore\_Person2Base\/} operation provided to read the
entire database from file.
"*/

  Restore_Person = VAR rep IN rep <--  restore_Person2Base END


END
