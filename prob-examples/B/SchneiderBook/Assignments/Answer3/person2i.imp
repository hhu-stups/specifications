IMPLEMENTATION

/*"
The implementation is built on the machines generated by BASE
generator; Person2Base.bse provides the specifications Person2Base and
Person2BaseCtx (a `context' machine) together with their implementations.
"*/

  Person2I

REFINES

  Person2

SEES

/*"
We must ensure that the context machine provided by the BASE generator
is in scope.
"*/

  String_TYPE, Bool_TYPE, Scalar_TYPE, Person2BaseCtx

IMPORTS

/*"
We import the generated machine.
"*/

  Person2Base(max_person,SEX)

PROPERTIES

/*"
We set our abstract object set equal to that provided in
{\em Person2BaseCtx\/}.
"*/

  PERSON = personbase_ABSOBJ

INVARIANT

/*"
Each of the abstract variables is equated to those provided in
{\em Person2Base\/}.
"*/

  person = personbase &
  person_name = name &
  person_age = age &
  person_sex = sex


OPERATIONS

/*"
{\bf Add\_person}\\
The operation provided for creating a new person, {\em make\_personbase\/},
takes a person's age and sex as input and returns a boolean value
indicating the success or otherwise of the operation (insufficient
memory may not have been allocated causing it to fail) together with a
token (which, if the operation is successful, points to the
newly-created person). Note that the name is not taken as a parameter:
mandatory strings, sequences and sets of a base are initialised to
empty when a new base record is created, and therefore if the create
operation is successful, we call the operation {\em mod\_name\/} with
the new token and the person's name as parameters; this operation may
also fail for the same reason as that given above, and in this case we
must be sure to kill the newly-created person.
"*/

  rep <-- Add_person(name_inp,age_inp,sex_inp) =
    VAR rep_0,new_person_0 IN
      rep_0,new_person_0<--make_personbase(age_inp,sex_inp);
      IF (rep_0=TRUE) THEN
        rep_0<--mod_name(new_person_0,name_inp);
        IF (rep_0=FALSE) THEN
          kill_personbase(new_person_0)
        END
      END;
      rep:=rep_0
    END;

/*"
{\bf Get\_person\_details}\\
The operation provided for a key search on a person's name,
{\em key\_search\_name\/} takes the name as parameter, and, if it is
stored, returns the token for the record, together with a report
indicating its success. We may then use the value operations provided
for age and sex, {\em val\_age\/} and {\em val\_sex\/}, both of which
take the token as input. If the key search operation was unsuccessful,
we return $0$ and {\em male\/} (the report indicating that the
operation failed).
"*/

  rep,age_out,sex_out <-- Get_person_details(name_inp) =
    VAR bb,person_tok IN
      bb,person_tok<--key_search_name(name_inp);
      rep:=bb;
      IF bb=TRUE THEN
        age_out<--val_age(person_tok);
        sex_out<--val_sex(person_tok)
      ELSE
        age_out:=0; sex_out:=male
      END
    END;        

/*"
{\bf Remove\_person}\\
This is similar to the above operation; if the key search is
successful we call the operation to remove a record,
{\em kill\_personbase\/}.
"*/

  rep <-- Remove_person(name_inp) =
    VAR bb,person_tok IN
      bb,person_tok<--key_search_name(name_inp);
      IF bb=TRUE THEN
         kill_personbase(person_tok)
      END;
      rep:=bb 
    END;      

/*"
{\bf Save\_Person}\\
We use the {\em save\_Person2Base\/} operation provided to write the
entire database to file.
"*/

  Save_Person = VAR rep IN rep <-- save_Person2Base END ;

/*"
{\bf  Restore\_Person}\\
We use the {\em restore\_Person2Base\/} operation provided to read the
entire database from file.
"*/

  Restore_Person = VAR rep IN rep <--  restore_Person2Base END;

/**************************************/

/* since the maximum age is 2^31 - 1, (ages are SCALAR values) the
operation Increment_age will not be correct if this is the age
associated with name_inp when the operation is called.  The
precondition of the specified operation has therefore been
strengthened so that this operation is only required to succeed if the
age to be incremented is less than 140. */

  rep <-- Increment_age(name_inp) = 
  VAR bb, nn IN
    rep, bb <-- key_search_name(name_inp);
    nn <-- val_age(bb);
    nn := nn+1;
    mod_age(bb,nn)
  END;

/* Note that that the operation mod_name of the base machine is itself not guaranteed to successfully change the name.  Thus the specification of Change_name must be adjusted to reflect this possibility. */

  rep <-- Change_name(name1_inp, name2_inp) = 
  VAR rep1, rep2, bb1, bb2  IN
    rep1, bb1 <-- key_search_name(name1_inp);
    rep2, bb2 <-- key_search_name(name2_inp);
    IF rep1 = TRUE & rep2 = FALSE
    THEN rep <-- mod_name(bb1, name2_inp)
    ELSE rep := FALSE
    END
  END;


  num <-- Under_age_query(age_inp) = 
  VAR age1, ll, bb, tot IN
    tot := 0;
    ll, bb <-- first_personbase;
    WHILE ll > 0
      DO age1 <-- val_age(bb);
         IF age1 <= age_inp THEN tot := tot + 1 END;
         ll, bb <-- next_personbase(ll,bb)
      INVARIANT (tot = card(age~[0..age_inp] /\ 
locate_personbase[ll+1..card(personbase)])) & ll : NAT
      VARIANT ll
    END;
    num := tot
  END;

  rep, num <-- Average_age_query =
  VAR age1, ll, bb, tot, sum IN
    sum := 0;
    ll, bb <-- first_personbase;
    tot := ll;
    WHILE ll > 0
      DO age1 <-- val_age(bb);
         sum := sum + age1; 
         ll, bb <-- next_personbase(ll,bb)
      INVARIANT sum = SIGMA (zz) . (zz : ll+1..card(personbase) | age(locate_personbase(zz))) 
         & ll : NAT
      VARIANT ll
    END;
    num := tot
  END

END
