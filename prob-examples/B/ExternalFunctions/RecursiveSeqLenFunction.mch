MACHINE RecursiveSeqLenFunction
/* A first working way to define recursive functions using the external_functions
   mechanism to store closures associated with recursive function names */
SETS
 ID={aa,bb,cc,dd}
DEFINITIONS
  EXTERNAL_FUNCTION_REC(A,B) == (STRING * A)-->B;
  EXTERNAL_FUNCTION_REC_LET(A) == (STRING * A)-->A;
  REC(F,A) == F(A);
  REC_LET(F,A) == A;
  SET_PREF_MAXINT ==  3 ;
  SET_PREF_SYMBOLIC == TRUE; SET_PREF_EXPAND_CLOSURES_FOR_STATE == FALSE 
CONSTANTS mylen
PROPERTIES
 mylen: (INTEGER<->ID) <-> INTEGER &
/* mylen: seq(ID) <-> INTEGER &  causes expansion */
 mylen = REC_LET("mylen",%x.(x=[]|0) \/ %x.(x:seq1(ID)|1+REC("mylen",tail(x)) ))
 /* Note that the body has no reference to the mylen variable (only "mylen" as a STRING is used)
  the un annotated original equation has a reference to mylen:
      mylen =  %x.(x=[]|0) \/ %x.(x/=[]|1+ mylen(tail(x)) )))
 This prevents ProB from being able to construct a closure.
 ideally, the REC_LET and REC could be automatically generated by statically analysing
  this equation
 */
VARIABLES xx
INVARIANT
 xx:seq(ID)
INITIALISATION xx:=[]
OPERATIONS
  Add(yy) = PRE yy:ID THEN xx:= yy -> xx END;
  r <-- GetMyLength = BEGIN r := mylen(xx) END
ASSERTIONS
  mylen([aa]) = 1;
  {x|([x]|->1) : mylen} = ID
 /*  ;   still expand mylen:
  mylen[ {[aa],[bb]} ] = {1}
  ;
  ([ [aa], [aa,bb] ] ; mylen) = [1,2] */
END

